\documentclass[english,serif,mathserif,xcolor=pdftex,dvipsnames,table]{beamer}
\usetheme[informal]{gc3}
\usepackage{gc3}

\title[OOP 2]{%
  Object-oriented programming, III
}
\author[GC3]{%
  GC3: Grid Computing Competence Center, \\
  University of Zurich
}
\date{Mar.~19--20, 2014}

\begin{document}

% title frame
\maketitle


\begin{frame}
  \frametitle{What we shall see in this part}

  Iterators: the Python way of implementing generalized sequences,
  e.g., ``infinite lists''.

  \+
  The \href{http://en.wikipedia.org/wiki/Template_method_pattern}{Template
    method}: an object-oriented pattern for code reuse.
\end{frame}


\begin{frame}
  \frametitle{Protocols}
  A \emph{protocol}, in the Python jargon, is an informal
  specification of what methods an object should implement in order to
  be used in a certain context.

  \+ For example, objects that implement the same methods as the
  \texttt{file} object are called ``file-like'' and can be used in
  stead of a real file.

  \+
  (This corresponds to the notion of \emph{interfaces} in other
  programming languages, but interfaces are usually a formal language
  construct.)
\end{frame}


\begin{frame}[fragile]
  \frametitle{\emph{Detour:} The Iterator Protocol}

  An \emph{iterator} is an object that can be used in the
  \texttt{in}-clause of a \texttt{for \ldots in \ldots} statement.

  \+
  An object can function as an iterator iff it implements a
  \texttt{next()} method, that:
  \begin{description}
  \item[\emph{either}] returns the next value in the iteration,
  \item[\emph{or}] use \lstinline|raise StopIteration| to signal the
    end of the iteration.
  \end{description}

  \+
  An object can be iterated over with \lstinline|for| if it implements a
  \lstinline|__iter__()| method that returns an iterator.

  \begin{references}
    \url{http://www.python.org/dev/peps/pep-0234/}
  \end{references}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Examples of Iterators, I}

  The \texttt{file} object:
\begin{lstlisting}
>>> fd = open('welcome.py', 'r')
>>> dir(fd)
['__class__', ~\ldots,~ 'name',
 'newlines', ~\HL{\tt 'next'}~, 'read',
 ~\ldots,~  'writelines', 'xreadlines']
\end{lstlisting}

  \+
  The \texttt{.next()} method of \texttt{file} objects returns the
  lines one by one:
\begin{lstlisting}
>>> fd.next()
'#! /usr/bin/env python\n'
>>> fd.next()
'\n'
>>> fd.next()
'print ("Welcome to Python!")\n'
\end{lstlisting}

\end{frame}


\begin{frame}[fragile]
  \frametitle{Examples of Iterators, II}

  You can get an iterator from any sequence with the \texttt{iter()} built-in function:
\begin{lstlisting}
>>> S = "Python"
>>> it = iter(S)
\end{lstlisting}

  \+
  The \texttt{.next()} method of such iterators returns the
  elements of the sequence one by one:
\begin{lstlisting}
>>> it.next()
'P'
>>> it.next()
'y'
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]
  \frametitle{A user-defined iterator}
  \begin{columns}[t]
    \begin{column}{0.5\textwidth}
\begin{lstlisting}
class Evens(object):

  def __init__(self, numbers):
    self._numbers = numbers

  def next(self):
      result = self._numbers.pop(0)
      while (result % 2) != 0:
          result = self._numbers.pop(0)
      return result

  def __iter__(self):
      return self
\end{lstlisting}
    \end{column}
    \begin{column}{0.5\textwidth}
      \raggedleft
      Iterate over the even numbers in a sequence.
    \end{column}
  \end{columns}

  \+
  {\scriptsize Source code available at:
    \url{https://raw.github.com/gc3-uzh-ch/python-course/master/evens.py}}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Example using \texttt{Evens}, I}
\begin{lstlisting}
>>> from evens import Evens
>>> e = Evens([1,2,3,5,7,8])
>>> e.next()
2
>>> e.next()
8
>>> e.next()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "evens.py", line 12, in next
    result = self._numbers.next()
StopIteration
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Example using \texttt{Evens}, II}
\begin{lstlisting}
>>> from evens import Evens
>>> e = Evens([1,2,3,5,7,8])
>>> for num in e:
...   print num
...
2
8
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]
  \begin{exercise}\small
    Define a \texttt{ReadPairs} class, with the following features.

    \+ A \texttt{ReadPairs} instance is created by passing a filename:
\begin{lstlisting}
>>> rt = ReadPairs('wt.csv')
\end{lstlisting}

    \+ Each time the \texttt{next()} method is called on a \texttt{ReadPairs} instance:
    \begin{enumerate}
    \item a line is read from the file passed to the constructor,
    \item that line is split at commas yielding two values,
    \item a 2-tuple consisting of the two values converted to integers is returned.
    \end{enumerate}

    \+ If a line is malformed (e.g., it does not contain exactly two
    values), then that line is ignored and \texttt{next()} should
    proceed to the next line.
  \end{exercise}
\end{frame}


\begin{frame}
  \frametitle{Detour: Regular Expression objects}
  The \texttt{re} module in the standard library provides
  \emph{regular expression searching}, allowing you to match a string
  against a pattern.

  \+
  \begin{describe}{re.search(pattern, string)}
    If \texttt{pattern} is matched anywhere in \texttt{string}, return
    a \emph{match object}.  Otherwise, return \texttt{None}.
  \end{describe}

  \+
  \begin{describe}{\emph{match}.group(0)}
    The entire string matched by \texttt{pattern} in a search operation.
  \end{describe}

  \+
  \begin{references}
    \url{http://docs.python.org/library/re.html}
  \end{references}
\end{frame}


\begin{frame}[fragile]
  \begin{exercise}
    Define a \texttt{Grep} iterator:
    \begin{itemize}
    \item a \texttt{Grep} instance is constructed by giving a file name and a regular expression pattern, e.g., \lstinline|g = Grep(filename, pattern)|
    \item Each call to the \texttt{next()} method returns the next line in the file that matches the regular expression \texttt{pattern}.
    \end{itemize}

    Use the \texttt{next()} method of file objects!
  \end{exercise}

  \+
  \begin{exercise}
    Define a \texttt{GrepOnlyMatching} class, similar to \texttt{Grep}
    except that its \texttt{next()} method returns only the part of
    the line that matched the \texttt{pattern} expression.
  \end{exercise}

  \+
  \begin{exercise}
    Define a \texttt{GrepExactly} class, similar to \texttt{Grep}
    except that \texttt{pattern} is now a fixed string, and the
    \texttt{next()} method returns lines that \emph{contain} it.
  \end{exercise}
\end{frame}


\begin{frame}[fragile]
  \frametitle{The ``Template method'' pattern}
\begin{lstlisting}
class Grep(object):

    def __init__(self, filename, pattern):
        self._file = open(filename, 'r')
        self._pattern = pattern

    def match(self, line):
        return re.search(self._pattern, line)

    def result(self, match, line):
        return line

    def next(self):
        line = self._file.next()
        match = self.match(line)
        while not match:
            line = self._file.next()
            match = self.match(line)
        return self.result(match, line)
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]
  \frametitle{The ``Template method'' pattern, I}
  \begin{columns}[t]
    \begin{column}{0.5\textwidth}
\begin{lstlisting}
class Grep(object):

  # parts omitted

  def next(self):
    line = self._file.next()
    match = ~\HL{self.match}~(line)
    while not match:
        line = self._file.next()
        match = ~\HL{self.match}~(line)
    return ~\HL{self.result}~(match, line)
\end{lstlisting}
    \end{column}
    \begin{column}{0.5\textwidth}
      \raggedleft
      These calls delegate the actual matching and
      extraction of the result from the line to instance methods.
    \end{column}
  \end{columns}
\end{frame}


\begin{frame}[fragile]
  \frametitle{The ``Template method'' pattern, II}
  \begin{columns}[t]
    \begin{column}{0.5\textwidth}
\begin{lstlisting}

class GrepOnlyMatching(Grep):
  ~\HL{\textbf{def} result}~(self, match, line):
    return match.group(0)

class GrepExactly(Grep):
  ~\HL{\textbf{def} match}~(self, line):
    return (self._pattern in line)
\end{lstlisting}
    \end{column}
    \begin{column}{0.5\textwidth}
      \raggedleft
      So we need only re-define those methods in derived
      classes to implement a variant behavior.
    \end{column}
  \end{columns}
\end{frame}


\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
