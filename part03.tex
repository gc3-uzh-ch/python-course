\documentclass[english,serif,mathserif,xcolor=pdftex,dvipsnames,table]{beamer}
\usetheme[informal]{gc3}
\usepackage{gc3}

\title[Sequences, Iteration]{%
  Sequences and iteration in Python
}
\author[GC3]{%
  GC3: Grid Computing Competence Center, \\
  University of Zurich
}
\date{Mar.~19--20, 2014}

\begin{document}

% title frame
\maketitle


\begin{frame}
  \frametitle{Sequences}

  Python provides a few built-in \emph{sequence} classes:
  \begin{description}
  \item[list] \emph{mutable}, possibly heterogeneous
  \item[tuple] \emph{immutable}, possibly heterogeneous
  \item[str] \emph{immutable}, only holds characters
  \end{description}
  Additional sequence types are provided by external modules. For
  instance,  the
  \href{http://numpy.scipy.org}{NumPy} package, which is commonly used in
  scientific Python codes, defines:
  \begin{description}
  \item[array] \emph{mutable}, homogeneous (like C/Fortran arrays)
  \end{description}

\end{frame}




\begin{frame}[fragile]
  \frametitle{Lists - \textit{(mutable, heterogeneous)}}
  Lists are by far the most common and used sequence type in Python.

  \+
  Lists are created and initialized by enclosing values into
  `\texttt{[}' and `\texttt{]}':
\begin{lstlisting}
>>> L = [ 'G', 'C' ]
\end{lstlisting}

  \+\pause
  You can append and remove items from a list:
\begin{lstlisting}
>>> L.append('3')
>>> print (L)
['G', 'C', '3']
\end{lstlisting}

  \+\pause
  You can append \textbf{any} object to it:
\begin{lstlisting}
>>> L.append([1, 2])
>>> print(L)
['G', 'C', '3', [1, 2]]
\end{lstlisting}

  % % \+
  % \begin{references}
  %   \url{http://docs.python.org/tutorial/datastructures.html#more-on-lists}
  % \end{references}
\end{frame}


\begin{frame}[fragile,fragile]
  \frametitle{Sequences, II}
  You can access individual items in a sequence using the postfix
  \texttt{[]} operator.

  \+
  Sequence indices start at 0.
  \pause
\begin{lstlisting}
>>> L = ['G', 'C', '3']
>>> print L[0], L[1], L[2]
'G' 'C' '3'
>>> S = 'GC3'
>>> print S[0], S[1], S[2]
'G' 'C' '3'
\end{lstlisting}

  \+\pause
  The \texttt{len()} function returns the number of items in any
  sequence (not just lists).
\begin{lstlisting}
>>> len(L)
3
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Slices}
  The notation \texttt{[$n$:$m$]} is used for accessing a \emph{slice}
  of sequence (the items at positions $n$, $n+1$, \ldots, $m-1$).
\pause
\begin{lstlisting}
>>> # list numbers from 0 to 9
>>> R = range(0,10)
>>> R[1:4]
[1, 2, 3]
\end{lstlisting}

  \+
  If $n$ is omitted it defaults to 0, if $m$ is omitted it defaults to
  the length of the sequence.

  \+\pause A \textit{slice} of a sequence is a sequence \textit{of the same
  type}.
\begin{lstlisting}
>>> S = 'zurich'
>>> S[0:4]
'zuri'
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]
  \frametitle{List mutation (1)}
  You can replace items in a \emph{mutable} sequence by assigning them
  a new value:
\begin{lstlisting}
>>> L[2] = 'Z'
>>> print L
['G', 'C', 'Z']
\end{lstlisting}

\pause
You can also replace an entire slice of a mutable sequence:
\begin{lstlisting}
>>> L[1:3] = ['a', 'b']
>>> print L
['G', 'a', 'b']
\end{lstlisting}

\pause
The new slice does not need to have the same length:
\begin{lstlisting}
>>> L[2:] = range(5)
>>> print L
['G', 'a', 0, 1, 2, 3, 4]
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]
  \frametitle{List mutation (2)}
  You can remove individual items from a list either by specifying
  the item:
\begin{lstlisting}
>>> L.remove('G')
>>> L
['a', 0, 1, 2, 3, 4]
\end{lstlisting}

\pause
or the position:

\begin{lstlisting}
>>> L.pop(1)
0
>>> L
['a', 1, 2, 3, 4]
\end{lstlisting}

\pause
Please note that the \texttt{remove()} method only removes
\textit{the first occurrence}:

\begin{lstlisting}
>>> L = ['a', 'b', 'a']
>>> L.remove('a')
>>> L
['b', 'a']
\end{lstlisting}
\begin{lstlisting}

\end{lstlisting}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Lists operators}
  You can concatenate two lists using the \texttt{+} operator:
  \begin{lstlisting}
>>> [1, 2] + [3, 4]
[1, 2, 3, 4]
  \end{lstlisting}

  \+
  You can mutate a list in place with the \texttt{+=} operator:
  \begin{lstlisting}
>>> L = [1, 2]
>>> L += [3, 4]
>>> print L
[1, 2, 3, 4]    
  \end{lstlisting}

\+
The \texttt{*} operator also works on lists:
  \begin{lstlisting}
>>> L = [1, 2]
>>> print L*3
[1, 2, 1, 2, 1, 2 ]
  \end{lstlisting}
\end{frame}

%%% for loops

\begin{frame}[fragile]
  \frametitle{\texttt{for}-loops}
    With the  \texttt{for} statement, you can loop over the values in
    a list:
\begin{lstlisting}
for i in range(0, 4):
  # loop block
  print (i*i)
\end{lstlisting}

  \+
  To break out of a \texttt{for} loop, use the \texttt{break}
  statement.

  \+
  To jump to the next iteration of a \texttt{for} loop, use the
  \texttt{continue} statement.
\end{frame}


\begin{frame}[fragile]
  The \texttt{for} statement can be used to loop over elements in \emph{any sequence}.

  \+
  \begin{columns}[c]
    \begin{column}{0.5\textwidth}
\begin{lstlisting}
>>> for val in ~\HL{[1,2,3]}~:
...   print val
1
2
3
\end{lstlisting}
    \end{column}
    \begin{column}{0.4\textwidth}
      \raggedleft
      Loop over lists
    \end{column}
  \end{columns}
\end{frame}


\begin{frame}[fragile]
  The \texttt{for} statement can be used to loop over elements in \emph{any sequence}.

  \+
  \begin{columns}[c]
    \begin{column}{0.5\textwidth}
\begin{lstlisting}
>>> for val in ~\HL{'GC3'}~:
...   print val
'G'
'C'
'3'
\end{lstlisting}
    \end{column}
    \begin{column}{0.4\textwidth}
      \raggedleft
      Loop over strings
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]

  If you want to loop over a \textit{sorted} sequence you can use the
  function \texttt{sorted()} :

  \begin{lstlisting}
>>> for val in sorted([1,3,4,2]):
...  print val
1
2
3
4
  \end{lstlisting}

and to loop over a sequence in \textit{inverted} order you can use the
\texttt{reversed()} function:

\begin{lstlisting}
>>> for val in reversed([1,3,4,2]):
...     print val
2
4
3
1
\end{lstlisting}

\end{frame}

%%% Exercise on for loops and lists

\begin{frame}[fragile]
  \begin{exercise}
    Write a function \texttt{odd} that takes a list of integers and
    returns a list of all the odd ones.
  \end{exercise}

  \+
  \begin{exercise}
    Write a function \texttt{concat} that takes a list of lists and
    returns the concatenation of those lists. For instance:
    \begin{lstlisting}
>>> concat([ [1,2,3], [4,5,6], [7,8,9] ])
[1, 2, 3, 4, 5, 6, 7, 8, 9]      
    \end{lstlisting}
  \end{exercise}
\end{frame}

%%% other containers

\begin{frame}
  \frametitle{Other containers}

  The following builtin containers are always available:
  \begin{description}
  \item[dict] \textit{mutable} key/value mapping.
  \item[set] \textit{mutable}, unordered set of \textit{unique} elements.
  \item[frozenset] \textit{immutable}, unordered set of
    \textit{unique} elements.
  \end{description}

  \pause
  Other specialized containers are available in the
  \texttt{collections} module:

  \begin{description}
  \item[dequeue] a generalization of stacks and queues
  \item[namedtuple] similar to a tuple, but allows you to access the
    elements \textit{by name}
  \item[OrderedDict] dictionary that remembers the order that the
    items were inserted.
  \end{description}
\end{frame}

%%% set container

\begin{frame}[fragile]
  \frametitle{Sets (1)} The \texttt{set} type implements an
  \textbf{unordered} container that holds exactly one object per
  equivalence class:
\begin{lstlisting}
>>> S = set()
>>> S.add(1)
>>> S.add('two')
>>> S.add(1)
>>> S
set([1, 'two'])
\end{lstlisting}

\end{frame}


\begin{frame}[fragile]
  \frametitle{Sets (2)}
You can create a set and add elements to it in one go:
\begin{lstlisting}
>>> S2 = set([1, 2, 3, 4])
\end{lstlisting}

and remove elements:

\begin{lstlisting}
>>> S2.remove(2)
>>> S2.pop()
1
>>> S2
set([3,4])
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Sets (3)}
  Sets are often used to get unique values from a list:
  \begin{lstlisting}
>>> L = [1, 1, 2, 2, 3, 3]
>>> set(L)
set([1, 2, 3])
 \end{lstlisting}

\+\pause
Of course, you can also create a list from a set:
\begin{lstlisting}
>>> S = set((1,2,3))
>>> list(S)
[1, 2, 3]
\end{lstlisting}

\+\pause
\begin{question}
  In what order will the set items appear in the list?
\end{question}

\end{frame}

%%% dictionaries

\begin{frame}[fragile]
  \frametitle{Dictionaries}
  The \texttt{dict} type implements a key/value mapping:
\begin{lstlisting}
>>> D = { }
>>> D['a'] = 1
>>> D[2] = 'b'
>>> D
{'a': 1, 2: 'b'}
\end{lstlisting}

  \+\pause
  Dictionaries can be created and initialized using the following syntax:
\begin{lstlisting}
>>> D = { 'a':1, 2:'b' }
>>> D['a']
1
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
  The \texttt{for} statement can be used to loop over keys of a dictionary:
  \+
  \begin{columns}[c]
    \begin{column}{0.5\textwidth}
\begin{lstlisting}
>>> D = dict(a=1, b=2)
>>> for val in ~\HL{D.keys()}~:
...   print val
'a'
'b'
\end{lstlisting}
    \end{column}
    \begin{column}{0.4\textwidth}
      \raggedleft
      Loop over dictionary~\emph{keys}.

      \emph{The \texttt{.keys()} part can be omitted, as it's the
        default!}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  If you want to loop over dictionary \emph{values}, you have to
  explicitly request it.

  \+
  \begin{columns}[c]
    \begin{column}{0.5\textwidth}
\begin{lstlisting}
>>> D = dict(a=1, b=2)
>>> for val in ~\HL{D.values()}~:
...   print val
1
2
\end{lstlisting}
    \end{column}
    \begin{column}{0.4\textwidth}
      \raggedleft
      Loop over dictionary~\emph{values}

      \emph{The \texttt{.values()} cannot be omitted!}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}
    \begin{exercise}
    Write a function \texttt{invert(D)} that takes a dictionary
    \texttt{D} and returns a dictionary \texttt{Dinv} with keys and
    values swapped. (We assume that \texttt{D} is 1-1.)
  \end{exercise}
\end{frame}

%%% Mutable vs immutable

\begin{frame}[fragile]
  \frametitle{Mutable vs Immutable}
  Some objects (e.g., \texttt{tuple}, \texttt{int}, \texttt{str})
  are \emph{immutable} and cannot be modified.
\begin{lstlisting}
>>> S = 'GC3'
>>> S[2] = '2'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
\end{lstlisting}


  \+
  \texttt{list}, \texttt{dict}, \texttt{set} and user-defined objects
  are \emph{mutable} and can be modified in-place.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Dictionary, sets and mutable objects} 

  A dictionary is essentially an
  \href{http://en.wikipedia.org/wiki/Hash_table}{Hash Table}, therefore keys of a
  dictionary must be \textit{hashable} objects.

  \+
  Similarly, elements of a \texttt{set} must be hashable too.

  \+\pause
  The hash of an object must not change over time, so:

  \begin{itemize}
  \pause
    \item
      \textit{Immutable} objects \textbf{can be} used as \texttt{dict} keys.
      
  \pause
    \item
      \textit{Mutable} objects  \textbf{cannot be} used as \texttt{dict} keys.
    \end{itemize}
    
    \+\pause
  But custom types can define an \verb|__hash__| method to compute their
  hash.
\end{frame}


%%% tuples

\begin{frame}[fragile]
  \frametitle{Tuples}
  Tuples are like lists
  \begin{lstlisting}
>>> T = (1, 2, 3)
>>> T[0]
1
>>> T[0:1]
(1,)
  \end{lstlisting}

  \+\pause
but they are \textit{immutable}

\begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
>>> T[0] = 'a'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
\end{lstlisting}
\end{frame}

%%% multiple assignment

\begin{frame}[fragile]
\frametitle{Multiple assignment}
% aka "destructuring bind"
You can assing multiple variables at the same time
\begin{lstlisting}
>>> a, b, c = (1, 2, 3)
>>> print a
1
>>> print b
2
\end{lstlisting}

\+

It works with any sequence:

\begin{lstlisting}
>>> a, b, c = 'GC3'
>>> print a
G
\end{lstlisting}

\pause
\begin{question}
  Can you think of a way to swap the values of two variables using this?
\end{question}
\pause
\begin{lstlisting}
>>> a, b = b, a
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Multiple assignment (2)}
Multiple assignment can be used in \texttt{for} statements as well.
\begin{lstlisting}
>>> L = [(1,'a'), (2,'b'), (3, 'c')]
>>> for num, char in L:
...     print ("num is " + str(num)
...            + ' and char is ' + char)
\end{lstlisting}

  \+
  This is particularly useful with functions that return a tuple.
  For instance the \texttt{enumerate()} function (look it up with
  \texttt{help()}!).
\end{frame}

\begin{frame}[fragile]

  \begin{exercise}
    Implement a \texttt{zip2} function, that takes a list of 2-tuples
    and returns \emph{two} lists: a list of all the first items in the
    pairs, and a list of all the second items in the pairs.

    \begin{lstlisting}
>>> zip2( [('a', 1), ('b', 2), ('c', 3)] )
(['a', 'b', 'c'], [1, 2, 3])      
    \end{lstlisting}
  \end{exercise}

  \+
  \begin{exercise}
    Read the documentation for the \texttt{dict.items} method, and
    give a solution of exercise \textbf{C} using multiple assignment
    and \texttt{dict.items}.
  \end{exercise}
\end{frame}

%%% the `in` operator

\begin{frame}[fragile]
  \frametitle{The `{\ttfamily\bfseries in}' operator}

  Use the \lstinline|in| operator to test for presence of an item in a
  collection.

  \begin{describe}{\lstinline|x in S|}
    Evaluates to \texttt{True} if \lstinline|x| is equal to a \emph{value}
    contained in the \lstinline|S| sequence (list, tuple, set).
  \end{describe}

  \begin{describe}{\lstinline|x in D|}
    Evaluates to \texttt{True} if \lstinline|x| is equal to a \emph{key}
    in the \lstinline|D| dictionary.
  \end{describe}

  \begin{describe}{\lstinline|x in T|}
    Evaluates to \texttt{True} if \lstinline|x| is a substring of
    string \lstinline|T|.
  \end{describe}

\end{frame}

\begin{frame}[fragile,fragile]
  \frametitle{The \texttt{in} operator and the \texttt{if} conditional
  }

  Testing for the existence of an element in a container is a very
  common pattern:
  \texttt{in} operator:

\begin{lstlisting}
>>> L = [1, 2, 3, 4]
>>> if 1 in L:
...   print "Found!"
...
Found!
\end{lstlisting}

% \+ Which is equivalent to the following, more verbose, less
% \textit{pythonic} form:
% \begin{lstlisting}
% >>> L = [1, 2, 3, 4]
% >>> for item in L:
% ...     if item == 1:
% ...         print "Found!"
% ...         break
% \end{lstlisting}
\end{frame}


%%% data structures recap

\begin{frame}
  \frametitle{Data structures recap}
  \begin{center}
    \begin{tabular}{>{\ttfamily}c|>{\ttfamily}c|>{\footnotesize}p{0.5\linewidth}}
      \rmfamily \textbf{mutable} & \rmfamily \textbf{immutable} & \\
      set & frozenset & unordered container of
      unique elements\\[1ex]
      list & tuple & ordered sequence\\[1ex]
      dict & $-$ & key/values mapping\\[1ex]
      $-$& str & ordered sequence of characters\\
    \end{tabular}
  \end{center}
\end{frame}


% \begin{frame}[fragile]
%   \frametitle{Useful data structures operations}

%   Read {\url{http://docs.python.org/tutorial/datastructures.html}}.

%   \+
%   Really, you will need it.

%   \+
%   And remember that \texttt{dir()} and \texttt{help()} are your friends!
% \end{frame}


%%% NOTE: This should be split in two slides

\begin{frame}[fragile]
  \frametitle{All variables are references}

  In Python, \textbf{all objects are ever passed by reference}.

  \+
  In particular, \textbf{variables always store a reference to an
    object}, never a copy!

  \+
  Hence, you have to be careful when modifying objects:
\begin{lstlisting}
>>> a = [1,2,3]
>>> b = a
>>> b.remove(2)
>>> print a
[1, 3]
\end{lstlisting}

   \+
   \href{http://tinyurl.com/cq3tcab}{Run this example} in the
   \href{http://pythontutor.com/}{Online Python Tutor} to better
   understand what's going on.

   \+
   {\small \em
     This applies particularly for variables that capture the arguments
     to a function call!}

\end{frame}


\begin{frame}[fragile]
  \frametitle{All variables are references (demo)}

  \href{http://www.pythontutor.com/}{www.pythontutor.com}
  \+

  \only<1>{\includegraphics[width=1.2\textheight]{fig/t1_screenshot_1.png}}
  \only<2>{\includegraphics[width=1.2\textheight]{fig/t1_screenshot_2.png}}
  \only<3>{\includegraphics[width=1.2\textheight]{fig/t1_screenshot_3.png}}
  \only<4>{\includegraphics[width=1.2\textheight]{fig/t1_screenshot_4.png}}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% I'm removing this slide because this does not always work. For %
% lists, for instances, it doesn't work as expected:             %
%                                                                %
% >>> l = range(3)                                               %
% >>> a = range(3)                                               %
% >>> b = a                                                      %
% >>> a                                                          %
% [0, 1, 2]                                                      %
% >>> b+= [4]                                                    %
% >>> a                                                          %
% [0, 1, 2, 4]                                                   %
% >>> b                                                          %
% [0, 1, 2, 4]                                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{frame}[fragile]
%   \frametitle{All variables are references, II}
%   \emph{However:}
% \begin{lstlisting}
% >>> a = 1
% >>> b = a
% >>> b += 1
% >>> a
% 1
% >>> b
% 2
% \end{lstlisting}
%   \begin{question}
%     How can you explain this?

%     \pause{The \texttt{b += 1} operator could be replaced by
%       \texttt{b = b + 1}, and the \texttt{b+1} expression yields a
%       \emph{new} value.}
%   \end{question}
% \end{frame}




\begin{frame}[fragile]
  \frametitle{Default values}

  Function arguments can have default values.
\begin{lstlisting}
>>> def hello(name='world'):
...   print ("Hello, " + name)
...
>>> hello()
'Hello, world'
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Variadic functions, I}
  Functions like \texttt{max} and \texttt{min} take a variable number of arguments.

  \+
  That is possible with user-defined functions too.

  \+
  If the last argument is prefixed with a \texttt{*} character,
  Python will make that argument into a \emph{tuple} of arguments
  passed to the function. (Except for the ones that have already been
  assigned names.)
\end{frame}


\begin{frame}[fragile,fragile]
  \frametitle{Variadic functions, II}
\begin{lstlisting}
>>> def varfn1(*args):
...   print args
>>> varfn1(1,2,3)
(1, 2, 3)
\end{lstlisting}

\begin{lstlisting}
>>> def varfn2(a, b, *rest):
...   print rest
>>> varfn1(1,2,3)
(3,)
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Variadic functions, III}
  You can call a function with an argument list that is only
  determined at run time.

  \+
  The unary \texttt{*} operator takes any sequence and makes it
  into a function argument list:
\begin{lstlisting}
>>> L = [1, 2, 3]
>>> max(*L)
3
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Named arguments}
Python allows calling a function with named arguments:
\begin{lstlisting}
hello(name="Alice")
\end{lstlisting}
When passing arguments by name, they can be passed in any order:
\begin{lstlisting}
>>> from fractions import Fraction
>>> Fraction(numerator=1, denominator=2)
Fraction(1, 2)
>>> Fraction(denominator=2, numerator=1)
Fraction(1, 2)
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Keyword arguments, I}
  Python lets you catch arbitrary named arguments.

  \+
  Prefix the very last argument name with \texttt{**}, and Python
  will make it into a dictionary: keys are actual argument names and
  dictionary values are actual argument values.

  \+
\begin{lstlisting}
>>> def kwfn1(**kwargs):
...   print kwargs
>>> kwfn1(a=1, b=2)
{'a':1, 'b':2}
\end{lstlisting}
\end{frame}


\begin{frame}[fragile,fragile]
  \frametitle{Keyword arguments, II}
  Keyword argument can be combined with positional arguments:
\begin{lstlisting}
>>> def kwfn1(x, y, **kwargs):
...   print "x=%s y=%s kwargs=%s" % (x, y, kwargs)
>>> kwfn1(0, 42, a=1, b=2)
x=0 y=42 kwargs={'a':1, 'b':2}
\end{lstlisting}

  \+
  \ldots and also with variadic arguments:
\begin{lstlisting}
>>> def kwfn2(x, *rest, **kwargs):
...   print ("x=%s rest=%s kwargs=%s"
...          % (x, rest, kwargs))
>>> kwfn2(0, 1, 2, 3, a=1, b=2)
x=0 rest=(1, 2, 3) kwargs={'a':1, 'b':2}
\end{lstlisting}
\end{frame}


\begin{frame}[fragile,fragile]
  \frametitle{Keyword arguments, III}
  You can pass to a function a set of keyword arguments that is
  determined only at run time.

  The \texttt{**} operator takes any \emph{dictionary} and turns it
  into the bundle of keyword arguments for a function:
\begin{lstlisting}
>>> D = { 'c':4, 'd':2 }
>>> kwfn2(x=1, **D)
x=1 rest=() kwargs={ 'c':4, 'd':2 }
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]
  \begin{exercise}
    Write a \texttt{maxarg} function, that takes arbitrary keyword
    arguments (but assume the values are all numbers), and returns the
    name of the argument with the largest value.

    \+
    Example:
\begin{lstlisting}
>>> maxarg(a=1, b=2)
'b'
\end{lstlisting}
  \end{exercise}
\end{frame}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
